{"mappings":";;;;;;;;AAgBA,KAAK,CAAC,qCAAe,GAAG,MAAM,CAAC,QAAQ,KAAK,CAAW,aAAG,QAAQ,GAAG,SAAS;SAK9D,yCAAW,CAAC,QAAe,GAAG,CAAM,OAAE,CAAC,WAAA,QAAQ,GAAG,qCAAe,EAAA,CAAC,GAAG,CAAC;AAAA,CAAC,EAAU,CAAC;IAChG,EAOG,AAPH;;;;;;;GAOG,AAPH,EAOG,CACH,GAAG,CAAC,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ;IAC5C,GAAG,CAAC,MAAM,GAAG,CAAC;QAAA,SAAS,EAAE,IAAI;IAAA,CAAC;IAC9B,GAAG,CAAC,eAAe,GAAG,CAAC,CAAC;IACxB,GAAG,CAAC,IAAI;IAER,GAAG,CAAC,QAAQ,GAAG,GAAG,CAAC,gBAAgB,EAAE,cAAc,GAAK,CAAC;QACvD,GAAG,EAAE,GAAG,CAAC,QAAQ,IAAI,cAAc,CAAE,CAAC;YACpC,EAAE,EAAE,QAAQ,CAAC,IAAI,KAAK,CAAW,cAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACpE,GAAG,CAAC,OAAO,GAAa,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,EAAE,IAAS,GAAK,IAAI,CAAC,aAAa,GAAG,CAA4C;;gBAC7I,EAAE,EAAE,OAAO,EAAE,CAAC;oBACZ,eAAe,CAAC,IAAI,CAAC,OAAO;oBAC5B,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC,CAA4C;oBAC9E,IAAI;oBACJ,IAAI,GAAG,4BAAU,CAAC,KAAK;gBACzB,CAAC;YACH,CAAC,MAAM,EAAE,EAAE,QAAQ,CAAC,IAAI,KAAK,CAAW,cAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC7E,GAAG,CAAC,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACnD,GAAG,CAAC,eAAe,GAAG,eAAe,CAAC,SAAS,EAAC,SAAS,GAAI,YAAY,CAAC,QAAQ,CAAC,SAAS;;gBAC5F,EAAE,EAAE,eAAe,IAAI,CAAC,EAAE,CAAC;oBACzB,IAAI;oBACJ,eAAe,GAAG,eAAe,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAK,CAAC,KAAK,eAAe;;oBAC1E,EAAE,EAAE,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAC/B,GAAG,CAAC,KAAK,GAAG,eAAe,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,aAAa,CAAC,CAA4C;wBAClH,IAAI,GAAG,4BAAU,CAAC,KAAK;oBACzB,CAAC,MACC,IAAI,GAAG,SAAS;gBAEpB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,QAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM;IAC/B,MAAM,KAAO,CAAC;QACZ,IAAI;QACJ,QAAQ,CAAC,UAAU;IACrB,CAAC;AACH,CAAC","sources":["packages/@react-aria/aria-modal-polyfill/src/index.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {hideOthers} from 'aria-hidden';\n\ntype Revert = () => void;\n\nconst currentDocument = typeof document !== 'undefined' ? document : undefined;\n\n/**\n * Acts as a polyfill for `aria-modal` by watching for added modals and hiding any surrounding DOM elements with `aria-hidden`.\n */\nexport function watchModals(selector:string = 'body', {document = currentDocument} = {}): Revert {\n  /**\n   * Listen for additions to the child list of the selected element (defaults to body). This is where providers render modal portals.\n   * When one is added, see if there is a modal inside it, if there is, then hide everything else from screen readers.\n   * If there was already a modal open and a new one was added, undo everything that the previous modal had hidden and hide based on the new one.\n   *\n   * If a modal container is removed, then undo the hiding based on the last hide others. Check if there are any other modals still around, and\n   * hide based on the last one added.\n   */\n  let target = document.querySelector(selector);\n  let config = {childList: true};\n  let modalContainers = [];\n  let undo: Revert | undefined;\n\n  let observer = new MutationObserver((mutationRecord) => {\n    for (let mutation of mutationRecord) {\n      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n        let addNode: Element = (Array.from(mutation.addedNodes).find((node: any) => node.querySelector?.('[aria-modal=\"true\"], [data-ismodal=\"true\"]')) as HTMLElement);\n        if (addNode) {\n          modalContainers.push(addNode);\n          let modal = addNode.querySelector('[aria-modal=\"true\"], [data-ismodal=\"true\"]') as HTMLElement;\n          undo?.();\n          undo = hideOthers(modal);\n        }\n      } else if (mutation.type === 'childList' && mutation.removedNodes.length > 0) {\n        let removedNodes = Array.from(mutation.removedNodes);\n        let nodeIndexRemove = modalContainers.findIndex(container => removedNodes.includes(container));\n        if (nodeIndexRemove >= 0) {\n          undo();\n          modalContainers = modalContainers.filter((val, i) => i !== nodeIndexRemove);\n          if (modalContainers.length > 0) {\n            let modal = modalContainers[modalContainers.length - 1].querySelector('[aria-modal=\"true\"], [data-ismodal=\"true\"]');\n            undo = hideOthers(modal);\n          } else {\n            undo = undefined;\n          }\n        }\n      }\n    }\n  });\n  observer.observe(target, config);\n  return () => {\n    undo?.();\n    observer.disconnect();\n  };\n}\n"],"names":[],"version":3,"file":"main.js.map"}